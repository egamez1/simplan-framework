/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.intuit.data.simplan.parser.sqlflow

import com.intuit.data.simplan.parser._
import com.intuit.data.simplan.parser.sql._
import com.intuit.data.simplan.parser.sql.Expression
import com.intuit.data.simplan.parser.sql.PrimaryExpression
import com.intuit.data.simplan.parser.sqlflow.ASTTreeTravasal.traverseExpression

/**
  * Traverses AST tree generated by ParseTree Visitor to extract Column , Tables and Expressions
  */
object ASTTreeTravasal {

  /*
   Returns a tuple of sourceColumns, expression and tartget column to construct graph
  */
  def traverseNamedExpression(namedExp: NamedExpression):(List[Column], Expression, Column)={
    val targetColumnName = namedExp.alias
    val expression:Expression = namedExp.expression
    val sourceColumns:List[Column] = traverseExpression(expression)
    val targetColumn = if(targetColumnName.isDefined){
      val column = Column(targetColumnName.get,None)
      column
    }else if (!sourceColumns.isEmpty){
      Column(sourceColumns.head.name, None )
    }
    // name cannot be determined
    else Column("",None)
    (sourceColumns, expression, targetColumn)
  }

  def traversePrimaryExpression(primaryExpression: PrimaryExpression):List[Column]={
    primaryExpression match {
      case derefrence:Dereference => {
        val column:Column = derefrence.column
        List(column)
      }
      case functionCall:FunctionCall => {
        val expressionOpt:Option[Expression] = functionCall.expression
        val list = if (expressionOpt.isDefined){
          val columns:List[Column] = traverseExpression(expressionOpt.get)
          columns
        } else List.empty
        list
      }
      case searchedCase:SearchedCase => {
        val expressions:List[Expression] = if (searchedCase.elseStmt.isDefined){
          searchedCase.when ++ searchedCase.thenStmt ++ List(searchedCase.elseStmt.get)
        } else  searchedCase.when ++ searchedCase.thenStmt

        val columns:List[Column] = expressions.map(expr=>{
          traverseExpression(expr)
        }).toList.flatten
        columns
      }
      case columnReference:ColumnReference => {
        //val identifier:String = columnReference.identifier
       // List(Column(identifier,None ))
        List(columnReference.column)
      }
      case columnReference:ColumnReferences => {
        columnReference.columns
      }
      case cast:Cast =>{
        val columns = traverseExpression(cast.expression)
        columns
      }
      case constant:Constant =>{
        // TODO Revisit
        // Avoid noise
        List.empty
      }
      case parenthesis:Paranthesis =>{
        val columns = traverseExpression(parenthesis.expression)
        columns

      }
      case subquery:SubQuery=>{
        val query = subquery.query
        val querySpec = query.querySpec
        val whereExpr:List[Expression] = if (querySpec.whereClause.isDefined){
          querySpec.whereClause.get
        }else List.empty

        val aggregationExpr:List[Expression] = if (querySpec.aggregationClause.isDefined){
          querySpec.aggregationClause.get
        }else List.empty

        val selectExpr:List[Expression] = querySpec.selectClause.namedExpressionSeq.map(_.expression).toList
        val expressions:List[Expression] = whereExpr ++ aggregationExpr ++ selectExpr
        val columns:List[Column] = expressions.map(exp=>traverseExpression(exp)).toList.flatten
        columns
      }
      case _ => List.empty
    }

  }

  def traverseExpression(expression:Expression):List[Column]= {
    expression match {
      case expr: ValueExpression => {
        val primaryExpr = expr.primaryQueryExpression
        traversePrimaryExpression(primaryExpr)
      }
      case expr: ComparisonExpression => {
        val right: Expression = expr.right
        val left: Expression = expr.left
        val rightColumns: List[Column] = traverseExpression(right)
        val leftColumns: List[Column] = traverseExpression(left)
        val list = rightColumns ++ leftColumns
        list
      }
      case expr: ArithmeticExpression => {
        val right: Expression = expr.right
        val left: Expression = expr.left
        val rightColumns: List[Column] = traverseExpression(right)
        val leftColumns: List[Column] = traverseExpression(left)
        val list = rightColumns ++ leftColumns
        list
      }
      case expr: LogicalExpression => {
        val right: Expression = expr.right
        val left: Expression = expr.left
        val rightColumns: List[Column] = traverseExpression(right)
        val leftColumns: List[Column] = traverseExpression(left)
        val list = rightColumns ++ leftColumns
        list
      }
    }
  }

  def traverseExpression(namedExp: NamedExpression):List[Column]={
    val expression:Expression = namedExp.expression
    val sourceColumns:List[Column] = traverseExpression(expression)
    sourceColumns
  }




}
